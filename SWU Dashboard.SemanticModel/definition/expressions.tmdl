expression Page = 1 meta [IsParameterQuery=true, Type="Any", IsParameterQueryRequired=true]
	lineageTag: 14c5a33f-a195-49a7-8f49-e2528ef7b586
	queryGroup: Parameter

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Number

expression Rows = 25 meta [IsParameterQuery=true, Type="Any", IsParameterQueryRequired=true]
	lineageTag: 42cb74ab-469d-45b9-a023-3220681a6120
	queryGroup: Parameter

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Number

expression 'Homepage Links' =
		let
		    #"HTML Code" = Web.BrowserContents("https://nexus.cascadegames.com/"),
		    #"Converted to Table" = #table(1, {{#"HTML Code"}}),
		    ExtractedLinks = Table.TransformColumns(#"Converted to Table", {"Column1", each Text.Split(_, "<a")}),
		    ExpandedLinks = Table.ExpandListColumn(ExtractedLinks, "Column1"),
		    ExtractHyperlinks = Table.AddColumn(ExpandedLinks, "Hyperlink", each Text.BetweenDelimiters([Column1], "href=""", """")),
		    ExtractLinkText = Table.AddColumn(ExtractHyperlinks, "LinkText", each Text.BetweenDelimiters([Column1], ">", "</a>")),
		    CleanedTable = Table.SelectColumns(ExtractLinkText, {"Hyperlink", "LinkText"}),
		    #"Added Custom" = Table.AddColumn(CleanedTable, "Custom", each if Text.StartsWith([Hyperlink], "http") then [Hyperlink] else "https://nexus.cascadegames.com" & [Hyperlink]),
		    #"Filtered Rows" = Table.SelectRows(#"Added Custom", each ([Hyperlink] <> "#")),
		    #"Renamed Columns" = Table.RenameColumns(#"Filtered Rows",{{"Custom", "WebLink"}})
		in
		    #"Renamed Columns"
	lineageTag: 321aee7b-6ff3-42cd-8011-d1d9ea36e5e1
	queryGroup: 'Cacade Tables'

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Table

expression 'Resource Links' =
		let
		    #"HTML Code" = Web.BrowserContents("https://nexus.cascadegames.com/resources/"),
		    #"Converted to Table" = #table(1, {{#"HTML Code"}}),
		    ExtractedLinks = Table.TransformColumns(#"Converted to Table", {"Column1", each Text.Split(_, "<a")}),
		    ExpandedLinks = Table.ExpandListColumn(ExtractedLinks, "Column1"),
		    ExtractHyperlinks = Table.AddColumn(ExpandedLinks, "Hyperlink", each Text.BetweenDelimiters([Column1], "href=""", """")),
		    ExtractLinkText = Table.AddColumn(ExtractHyperlinks, "LinkText", each Text.BetweenDelimiters([Column1], ">", "</a>")),
		    CleanedTable = Table.SelectColumns(ExtractLinkText, {"Hyperlink", "LinkText"}),
		    #"Added Custom" = Table.AddColumn(CleanedTable, "Custom", each if Text.StartsWith([Hyperlink], "http") then [Hyperlink] else "https://nexus.cascadegames.com" & [Hyperlink]),
		    #"Filtered Rows" = Table.SelectRows(#"Added Custom", each ([Hyperlink] <> "#")),
		    #"Renamed Columns" = Table.RenameColumns(#"Filtered Rows",{{"Custom", "WebLink"}})
		in
		    #"Renamed Columns"
	lineageTag: 15aa0470-41e9-44b1-a8c7-01bf344200d9
	queryGroup: 'Cacade Tables'

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Table

expression Groups =
		let
		    Raw =
		        Json.Document(
		            Web.Contents(
		                "https://tcgcsv.com",
		                [
		                    RelativePath = "tcgplayer/79/groups"
		                ]
		            )
		        ),
		    data = Raw[results],
		    ToTable = Table.FromList(data, Splitter.SplitByNothing(), null, null, ExtraValues.Error),
		    Expanded =
		        Table.ExpandRecordColumn(
		            ToTable,
		            "Column1",
		            {"groupId", "name", "abbreviation", "isSupplemental", "publishedOn", "modifiedOn", "categoryId"},
		            {"groupId", "name", "abbreviation", "isSupplemental", "publishedOn", "modifiedOn", "categoryId"}
		        )
		in
		    Expanded
	lineageTag: 878ef626-98c7-4118-a732-40c82bbeafa8
	queryGroup: 'TCGPlayer Pricing'

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Table

expression GetGroupProducts = ```
		(group as number) =>
		let
		    Source = Json.Document(
		        Web.Contents(
		            "https://tcgcsv.com", 
		            [
		                RelativePath = "/tcgplayer/79/" & Number.ToText(group) & "/products"
		            ]
		        )
		    ),
		    data = Source[results]
		in
		    data
		```
	lineageTag: d5deeb59-19a3-4587-8d3c-29cf31ef0e98
	queryGroup: Function

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Function

expression GetGroupPrices = ```
		(group as number) =>
		let
		    Source = Json.Document(
		        Web.Contents(
		            "https://tcgcsv.com", 
		            [
		                RelativePath = "/tcgplayer/79/" & Number.ToText(group) & "/prices"
		            ]
		        )
		    ),
		    data = Source[results]
		in
		    data
		```
	lineageTag: d150f783-714e-4da5-bb2b-be980313c636
	queryGroup: Function

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Function

expression Products =
		let
		    // pull group list first
		    groupTable = Groups,
		    groupIds = groupTable[groupId],
		
		    // local helper: fetch products for ONE group id
		    GetGroupProducts = (g as number) =>
		        let
		            Raw =
		                Json.Document(
		                    Web.Contents(
		                        "https://tcgcsv.com",
		                        [
		                            // example final URL:
		                            // https://tcgcsv.com/tcgplayer/79/<groupId>/products
		                            RelativePath = "tcgplayer/79/" & Text.From(g) & "/products"
		                        ]
		                    )
		                ),
		            data = Raw[results]   // this is a LIST of product records
		        in
		            data,
		
		    // call API for every group and capture both the groupId and its data
		    results =
		        List.Transform(
		            groupIds,
		            each [
		                group = _,
		                data = try GetGroupProducts(_) otherwise null
		            ]
		        ),
		
		    // drop any nulls (failed calls etc.)
		    cleanResults = List.Select(results, each [data] <> null),
		
		    // turn into a table so we can expand
		    ConvertedToTable = Table.FromList(cleanResults, Splitter.SplitByNothing(), null, null, ExtraValues.Error),
		    ExpandedColumn1 =
		        Table.ExpandRecordColumn(
		            ConvertedToTable,
		            "Column1",
		            {"group", "data"},
		            {"group", "data"}
		        ),
		
		    // expand the list of product records into rows
		    ExpandedData = Table.ExpandListColumn(ExpandedColumn1, "data"),
		
		    // expand each product record into columns
		    ExpandedData1 =
		        Table.ExpandRecordColumn(
		            ExpandedData,
		            "data",
		            {
		                "productId",
		                "name",
		                "cleanName",
		                "imageUrl",
		                "categoryId",
		                "groupId",
		                "url",
		                "modifiedOn",
		                "imageCount",
		                "presaleInfo",
		                "extendedData"
		            },
		            {
		                "productId",
		                "name",
		                "cleanName",
		                "imageUrl",
		                "categoryId",
		                "groupId",
		                "url",
		                "modifiedOn",
		                "imageCount",
		                "presaleInfo",
		                "extendedData"
		            }
		        ),
		
		    // extendedData is itself a list; explode it
		    ExpandedExtendedData = Table.ExpandListColumn(ExpandedData1, "extendedData"),
		
		    // now expand extendedData rows (things like card number metadata)
		    ExpandedExtendedData1 =
		        Table.ExpandRecordColumn(
		            ExpandedExtendedData,
		            "extendedData",
		            {"name", "displayName", "value"},
		            {"name.1", "displayName", "value"}
		        ),
		
		    // keep only the extendedData rows where name = "Number"
		    FilteredRows = Table.SelectRows(ExpandedExtendedData1, each ([name.1] = "Number")),
		
		    // clean up columns
		    RemovedColumns = Table.RemoveColumns(FilteredRows, {"name.1", "displayName", "presaleInfo"}),
		    RenamedColumns = Table.RenameColumns(RemovedColumns, {{"value", "cardNumber"}}),
		
		    // join back to Groups to get set info (set name, abbreviation)
		    MergedQueries =
		        Table.NestedJoin(
		            RenamedColumns,
		            {"group"},
		            groupTable,
		            {"groupId"},
		            "Groups",
		            JoinKind.LeftOuter
		        ),
		    ExpandedGroups =
		        Table.ExpandTableColumn(
		            MergedQueries,
		            "Groups",
		            {"name", "abbreviation"},
		            {"name.1", "abbreviation"}
		        ),
		    RenamedColumns1 = Table.RenameColumns(ExpandedGroups, {{"name.1", "setName"}}),
		
		    ReorderedColumns =
		        Table.ReorderColumns(
		            RenamedColumns1,
		            {
		                "group",
		                "productId",
		                "name",
		                "cleanName",
		                "imageUrl",
		                "categoryId",
		                "groupId",
		                "url",
		                "modifiedOn",
		                "imageCount",
		                "cardNumber",
		                "abbreviation",
		                "setName"
		            }
		        )
		in
		    ReorderedColumns
	lineageTag: bc50e7e4-6317-4fd0-8909-14e74f798e7f
	queryGroup: 'TCGPlayer Pricing'

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Table

expression Prices =
		let
		    // pull group list first
		    groupTable = Groups,
		    groupIds = groupTable[groupId],
		
		    // local helper: fetch PRICES for a single group
		    GetGroupPrices = (g as number) =>
		        let
		            Raw =
		                Json.Document(
		                    Web.Contents(
		                        "https://tcgcsv.com",
		                        [
		                            // expected final URL:
		                            // https://tcgcsv.com/tcgplayer/79/<groupId>/prices
		                            RelativePath = "tcgplayer/79/" & Text.From(g) & "/prices"
		                        ]
		                    )
		                ),
		            data = Raw[results]   // list of price records
		        in
		            data,
		
		    // call API for each group id
		    results =
		        List.Transform(
		            groupIds,
		            each [
		                group = _,
		                data = try GetGroupPrices(_) otherwise null
		            ]
		        ),
		
		    // remove nulls
		    cleanResults = List.Select(results, each [data] <> null),
		
		    // shape into a table
		    ConvertedToTable = Table.FromList(cleanResults, Splitter.SplitByNothing(), null, null, ExtraValues.Error),
		    ExpandedColumn1 =
		        Table.ExpandRecordColumn(
		            ConvertedToTable,
		            "Column1",
		            {"group", "data"},
		            {"group", "data"}
		        ),
		
		    // expand each group's list of price rows
		    ExpandedData = Table.ExpandListColumn(ExpandedColumn1, "data"),
		
		    // expand each price record
		    ExpandedData1 =
		        Table.ExpandRecordColumn(
		            ExpandedData,
		            "data",
		            {
		                "productId",
		                "lowPrice",
		                "midPrice",
		                "highPrice",
		                "marketPrice",
		                "directLowPrice",
		                "subTypeName"
		            },
		            {
		                "productId",
		                "lowPrice",
		                "midPrice",
		                "highPrice",
		                "marketPrice",
		                "directLowPrice",
		                "subTypeName"
		            }
		        ),
		
		    // drop junk / empties
		    FilteredRows =
		        Table.SelectRows(
		            ExpandedData1,
		            each [productId] <> null and [productId] <> ""
		        )
		in
		    FilteredRows
	lineageTag: 0bb00db4-f673-4919-a97d-898f34c83a0a
	queryGroup: 'TCGPlayer Pricing'

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Table

expression 'File Path' = "C:\PlaceHolder\PathToProject" meta [IsParameterQuery=true, Type="Any", IsParameterQueryRequired=true]
	lineageTag: 364fe700-e36b-4e0c-aba8-9fd5c7daf978
	queryGroup: Parameter

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Text

expression 'Rules Clarifications' =
		let
		    // Load markdown content from GitHub Gist
		    Source = Text.FromBinary(Web.Contents("https://gist.githubusercontent.com/macfergusson/256a534a98fc1d45f2595503f7d54953/raw/c55e1e4c5bedef1ecfaa18e6ce26374a895a9d32/SWU_Resources.md")),
		
		    // Split the text into blocks
		    Blocks = Text.Split(Source, "-------------------------------------------------"),
		    TrimmedBlocks = List.Transform(Blocks, each Text.Trim(_)),
		    NonEmptyBlocks = List.Select(TrimmedBlocks, each Text.Length(_) > 0),
		
		    // Parse each block
		    ParseBlock = (block as text) =>
		        let
		            Lines = Text.Split(block, "#(lf)"),
		
		            // Get line index of "**Question:**"
		            QuestionHeaderIndex = List.PositionOfAny(Lines, List.Select(Lines, each Text.Contains(_, "**Question:**"))),
		
		            // Lines after "**Question:**"
		            AfterQuestionHeader = List.Skip(Lines, QuestionHeaderIndex + 1),
		
		            // First line containing the actual bolded question
		            FirstBoldLine = List.First(List.Select(AfterQuestionHeader, each Text.Contains(_, "**"))),
		
		            // SAFELY extract first bolded text using Text.BetweenDelimiters
		            QuestionText = Text.BetweenDelimiters(FirstBoldLine, "**", "**"),
		
		                        // Get index of the bolded question line
		            FirstBoldIndex = List.PositionOf(AfterQuestionHeader, FirstBoldLine),
		
		            // Lines after the bolded question
		            AfterBold = List.Skip(AfterQuestionHeader, FirstBoldIndex + 1),
		
		            // Find the index of the first CR line in the full Lines list
		            CRLineIndex = List.PositionOfAny(Lines, List.Select(Lines, each Text.StartsWith(Text.Trim(_), "CR "))),
		
		            // If CR found, figure out how far it is from AfterBold
		            CRAbsoluteIndex = if CRLineIndex <> -1 then CRLineIndex else List.Count(Lines),
		            AbsoluteAfterBoldStart = List.PositionOf(Lines, AfterBold{0}),
		            ExampleLineCount = CRAbsoluteIndex - AbsoluteAfterBoldStart,
		
		            // Extract example lines and join
		            ExampleLines = List.FirstN(AfterBold, ExampleLineCount),
		            ExampleText = Text.Combine(ExampleLines, " "),
		
		
		            // Extract CRs
		            CRLines = List.Select(Lines, each Text.StartsWith(Text.Trim(_), "CR ")),
		            CRTextLines = List.Select(Lines, each Text.StartsWith(Text.Trim(_), "*") and not Text.StartsWith(_, "**")),
		            CRs = List.Zip({CRLines, CRTextLines}),
		            CRTable = Table.FromRecords(List.Transform(CRs, each [
		                CRReference = Text.Trim(_{0}),
		                CRText = Text.Middle(Text.Trim(_{1}), 1, Text.Length(Text.Trim(_{1})) - 2)
		            ])),
		
		            // Extract answer
		            AnswerIndex = List.PositionOfAny(Lines, List.Select(Lines, each Text.Contains(_, "**Answer:**"))),
		            AfterAnswer = List.Skip(Lines, AnswerIndex + 1),
		            EndOfAnswerIndex = List.PositionOfAny(AfterAnswer, List.Select(AfterAnswer, each Text.Contains(_, "`"))),
		            AnswerTextLines = if EndOfAnswerIndex = -1 then AfterAnswer else List.FirstN(AfterAnswer, EndOfAnswerIndex),
		            AnswerText = Text.Combine(AnswerTextLines, " "),
		
		            // Extract date
		            DateLine = List.First(List.Select(Lines, each Text.Contains(_, "`(Answer shared on"))),
		            DateText = Text.Middle(
		                DateLine,
		                Text.PositionOf(DateLine, "(") + 1,
		                Text.PositionOf(DateLine, ")") - Text.PositionOf(DateLine, "(") - 1
		            )
		        in
		            [
		                Question = QuestionText,
		                Example = ExampleText,
		                CRs = CRTable,
		                Answer = AnswerText,
		                Date = DateText
		            ],
		
		    // Apply parsing to all blocks
		    Parsed = List.Transform(NonEmptyBlocks, each ParseBlock(_)),
		    Output = Table.FromRecords(Parsed),
		    #"Filtered Rows" = Table.SelectRows(Output, each ([Question] <> ""))
		in
		    #"Filtered Rows"
	lineageTag: 50aa8a7b-d70a-411b-8749-dae03ad30538
	queryGroup: 'Cacade Tables'

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Table

expression Base =
		let
		    // Use your parameter for page size
		    PageSize = #"Rows",
		
		    // Fetch ONE page of results and return it as a table
		    GetPage = (p as number) as table =>
		        let
		            Raw =
		                Json.Document(
		                    Web.Contents(
		                        "https://admin.starwarsunlimited.com",
		                        [
		                            RelativePath = "api/card-list",
		                            Query = [
		                                #"locale" = "en",
		                                #"pagination[page]" = Text.From(p),
		                                #"pagination[pageSize]" = Text.From(PageSize)
		                            ]
		                        ]
		                    )
		                ),
		
		            // This is the 'data' field from the JSON. It's coming back as a LIST.
		            DataList = Raw[data],
		
		            // Convert list of records → table
		            // If DataList is {} (empty list), this returns an empty table (0 rows), which is what we want.
		            DataTable = Table.FromRecords(DataList)
		        in
		            DataTable,
		
		    // Generate each page until we get an empty table
		    PageList =
		        List.Generate(
		            // initializer
		            () => [Page = 1, Result = GetPage(1)],
		
		            // condition to keep iterating
		            each [Result] <> null and Table.RowCount([Result]) > 0,
		
		            // next record
		            each [Page = [Page] + 1, Result = GetPage([Page] + 1)],
		
		            // what to collect into the list
		            each [Result]
		        ),
		
		    // Combine all pages (list of tables) into one final table
		    AllPages = Table.Combine(PageList),
		    #"Expanded attributes" = Table.ExpandRecordColumn(AllPages, "attributes", {"title", "subtitle", "cardNumber", "cardCount", "artist", "artFrontHorizontal", "artBackHorizontal", "hasFoil", "cost", "hp", "power", "text", "textStyled", "deployBox", "deployBoxStyled", "epicAction", "epicActionStyled", "linkHtml", "cardId", "createdAt", "updatedAt", "publishedAt", "locale", "hyperspace", "unique", "showcase", "cardUid", "rules", "rulesStyled", "serialCode", "upgradeHp", "upgradePower", "artFront", "artBack", "artThumbnail", "localizations", "aspects", "aspectDuplicates", "type", "type2", "traits", "arenas", "keywords", "rarity", "expansion", "variantTypes", "variantOf", "reprintOf", "validationId"}, {"title", "subtitle", "cardNumber", "cardCount", "artist", "artFrontHorizontal", "artBackHorizontal", "hasFoil", "cost", "hp", "power", "text", "textStyled", "deployBox", "deployBoxStyled", "epicAction", "epicActionStyled", "linkHtml", "cardId", "createdAt", "updatedAt", "publishedAt", "locale", "hyperspace", "unique", "showcase", "cardUid", "rules", "rulesStyled", "serialCode", "upgradeHp", "upgradePower", "artFront", "artBack", "artThumbnail", "localizations", "aspects", "aspectDuplicates", "type", "type2", "traits", "arenas", "keywords", "rarity", "expansion", "variantTypes", "variantOf", "reprintOf", "validationId"}),
		    #"Expanded type" = Table.ExpandRecordColumn(#"Expanded attributes", "type", {"data"}, {"type.data"}),
		    #"Expanded type.data" = Table.ExpandRecordColumn(#"Expanded type", "type.data", {"attributes"}, {"type.data.attributes"}),
		    #"Expanded type.data.attributes" = Table.ExpandRecordColumn(#"Expanded type.data", "type.data.attributes", {"name"}, {"type.data.attributes.name"}),
		    #"Filtered Rows" = Table.SelectRows(#"Expanded type.data.attributes", each not Text.Contains([type.data.attributes.name], "Token"))
		in
		    #"Filtered Rows"
	lineageTag: a2ae0752-1444-4598-9bab-521bc7ee93a2
	queryGroup: 'API Tables'

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Table

expression 'Google Sheets Link' = "https://docs.google.com/spreadsheets/d/1ymASHx_Tr96ny7D32RozMHar14Bde2wRLNIRAaOMiv8/edit?gid=1884736088#gid=1884736088" meta [IsParameterQuery=true, Type="Any", IsParameterQueryRequired=true]
	lineageTag: a0b3f9e0-7e5b-478d-856e-5110b80252d9
	queryGroup: Parameter

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Text

expression GetSWUTourneys =
		(tourney as number) =>
		let
		    Source = Json.Document(
		        Web.Contents(
		            "https://swustats.net/TCGEngine/APIs/GetMeleeTournament.php?id=" & Number.ToText(tourney)
		        )
		    ),
		    Decks = Source[decks],
		    DecksTable = if List.Count(Decks) > 0 then
		        Table.FromRecords(Decks)
		    else
		        #table({}, {})
		in
		    DecksTable
	lineageTag: 76f50ea5-4036-4f12-aff2-53eb60f51177
	queryGroup: Function

	annotation PBI_NavigationStepName = Navigation

	annotation PBI_ResultType = Function

